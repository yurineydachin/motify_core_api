// It's autogenerated file. It's not recommended to modify it.
package adapter

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"github.com/coreos/etcd/client"
	"motify_core_api/godep_libs/discovery/balancer"
	"motify_core_api/godep_libs/discovery/provider"
	gotrace "motify_core_api/godep_libs/go-trace"
	"motify_core_api/godep_libs/mobapi_lib/logger"
	"motify_core_api/godep_libs/mobapi_lib/utils"
	"io/ioutil"
	"net/http"
	"net/url"
	"runtime"
	"strings"
	"time"
)

type IBalancer interface {
	Next() (string, error)
}

type Callbacks struct {
	OnStart          func(ctx context.Context, req *http.Request)
	OnFinish         func(ctx context.Context, req *http.Request, startTime time.Time)
	OnError          func(ctx context.Context, req *http.Request, err error)
	OnPanic          func(ctx context.Context, req *http.Request, r interface{}, trace []byte)
	OnPrepareRequest func(ctx context.Context, req *http.Request)
}

type ExampleGoRPC struct {
	client      *http.Client
	serviceName string
	balancer    IBalancer
	callbacks   Callbacks
}

func NewExampleGoRPC(client *http.Client, balancer IBalancer, callbacks Callbacks) *ExampleGoRPC {
	if client == nil {
		client = http.DefaultClient
	}
	return &ExampleGoRPC{
		//		client: &http.Client{
		//			Transport: &http.Transport{
		//				//DisableCompression: true,
		//				MaxIdleConnsPerHost: 20,
		//			},
		//			Timeout: apiTimeout,
		//		},
		serviceName: "ExampleGoRPC",
		balancer:    balancer,
		callbacks:   callbacks,
		client:      client,
	}
}

func (api *ExampleGoRPC) HelloWorldV1(ctx context.Context, options HelloWorldV1Args) (string, error) {
	var result string
	err := api.set(ctx, "/hello/world/v1/", options, &result, nil)
	return result, err
}

func (api *ExampleGoRPC) HelloWorldV2(ctx context.Context, options HelloWorldV2Args) (HelloWorldV2Response, error) {
	var result HelloWorldV2Response
	err := api.set(ctx, "/hello/world/v2/", options, &result, nil)
	return result, err
}

func (api *ExampleGoRPC) SearchGoogleV1(ctx context.Context, options SearchGoogleV1Args) ([]SearchGoogleV1Res, error) {
	var result []SearchGoogleV1Res
	err := api.set(ctx, "/search/google/v1/", options, &result, _SearchGoogleV1ErrorsMapping)
	return result, err
}

type HelloWorldV1Args struct {
}

type HelloWorldV2Args struct {
}

type HelloWorldV2Response string

type SearchGoogleV1Args struct {
	Query string `json:"query"`
}

type SearchGoogleV1Res struct {
	Title string `json:"title"`
	URL   string `json:"url"`
}

type SearchGoogleV1Errors int

const (
	SearchGoogleV1Errors_EMPTY_RESULT = iota
)

var _SearchGoogleV1ErrorsMapping = map[string]int{
	"EMPTY_RESULT": SearchGoogleV1Errors_EMPTY_RESULT,
}

// TODO: duplicates http_json.httpSessionResponse
type httpSessionResponse struct {
	Result string          `json:"result"` //OK or ERROR
	Data   json.RawMessage `json:"data"`
	Error  string          `json:"error"`
}

func (api *ExampleGoRPC) set(ctx context.Context, path string, data interface{}, buf interface{}, handlerErrors map[string]int) (err error) {
	startTime := time.Now()

	var apiURL string
	var req *http.Request

	if api.callbacks.OnStart != nil {
		api.callbacks.OnStart(ctx, req)
	}

	if api.callbacks.OnFinish != nil {
		defer api.callbacks.OnFinish(ctx, req, startTime)
	}

	defer func() {
		if r := recover(); r != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			n := runtime.Stack(buf, false)
			trace := buf[:n]

			err = fmt.Errorf("panic while calling %q service: %v", api.serviceName, r)
			if api.callbacks.OnPanic != nil {
				api.callbacks.OnPanic(ctx, req, r, trace)
			}
		}
	}()

	apiURL, err = api.balancer.Next()
	if err != nil {
		if api.callbacks.OnError != nil {
			api.callbacks.OnError(ctx, req, err)
		}
		return err
	}

	b := bytes.NewBuffer(nil)
	encoder := json.NewEncoder(b)
	if err := encoder.Encode(data); err != nil {
		err = fmt.Errorf("could not marshal data %+v: %v", data, err)
		if api.callbacks.OnError != nil {
			api.callbacks.OnError(ctx, req, err)
		}
		return err
	}

	req, err = http.NewRequest("POST", createRawURL(apiURL, path, nil), b)
	if err != nil {
		if api.callbacks.OnError != nil {
			api.callbacks.OnError(ctx, req, err)
		}
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	if api.callbacks.OnPrepareRequest != nil {
		api.callbacks.OnPrepareRequest(ctx, req)
	}

	if err := doRequest(api.client, req, buf, handlerErrors); err != nil {
		if api.callbacks.OnError != nil {
			api.callbacks.OnError(ctx, req, err)
		}
		return err
	}

	return nil
}

func createRawURL(url, path string, values url.Values) string {
	var buf bytes.Buffer
	buf.WriteString(strings.TrimRight(url, "/"))
	//buf.WriteRune('/')
	//buf.WriteString(strings.TrimLeft(path, "/"))
	// path must contain leading /
	buf.WriteString(path)
	if len(values) > 0 {
		buf.WriteRune('?')
		buf.WriteString(values.Encode())
	}
	return buf.String()
}

func doRequest(client *http.Client, request *http.Request, buf interface{}, handlerErrors map[string]int) error {
	// Run
	response, err := client.Do(request)
	if err != nil {
		return err
	}
	defer response.Body.Close()

	// Handle error
	if response.StatusCode != http.StatusOK {
		switch response.StatusCode {
		// TODO separate error types for different status codes (and different callbacks)
		/*
		   case http.StatusForbidden:
		   case http.StatusBadGateway:
		   case http.StatusBadRequest:
		*/
		default:
			return fmt.Errorf("Request %q failed. Server returns status code %d", request.URL.RequestURI(), response.StatusCode)
		}
	}

	// Read response
	result, err := ioutil.ReadAll(response.Body)
	if err != nil {
		return err
	}

	var mainResp httpSessionResponse
	if err := json.Unmarshal(result, &mainResp); err != nil {
		return fmt.Errorf("request %q failed to decode response %q: %v", request.URL.RequestURI(), string(result), err)
	}

	if mainResp.Result == "OK" {
		if err := json.Unmarshal(mainResp.Data, buf); err != nil {
			return fmt.Errorf("request %q failed to decode response data %+v: %v", request.URL.RequestURI(), mainResp.Data, err)
		}
		return nil
	}

	if mainResp.Result == "ERROR" {
		errCode, ok := handlerErrors[mainResp.Error]
		if ok {
			return &ServiceError{
				Code:    errCode,
				Message: mainResp.Error,
			}
		}
	}

	return fmt.Errorf("request %q returned incorrect response %q", request.URL.RequestURI(), string(result))
}

// ServiceError uses to separate critical and non-critical errors which returns in external service response.
// For this type of error we shouldn't use 500 error counter for librato
type ServiceError struct {
	Code    int
	Message string
}

// Error method for implementing common error interface
func (err *ServiceError) Error() string {
	return err.Message
}

func NewBalancer(etcdClient client.Client, serviceName, venture, env string) balancer.ILoadBalancer {
	logger := utils.DiscoveryLogger{}

	// see more details how to init ETCDv3 provider and ETCDv2 client
	// in https://bitbucket.lzd.co/projects/GOLIBS/repos/discovery/browse/UPGRADE.md?at=refs%2Fheads%2FGOLIBS-1080
	var provider provider.IProvider
	var etcdClientV2 client.Client

	opts := balancer.FallbackBalancerEtcd2Options{
		ServiceName:  serviceName,
		Venture:      venture,
		Environment:  env,
		BalancerType: balancer.TypeRoundRobin,
	}

	return balancer.NewFallbackBalancerEtcd2(provider, etcdClientV2, logger, opts)
}

type Example struct {
	*ExampleGoRPC
}

func NewExample(client *http.Client, balancer IBalancer, parentMonitor interfaces.IMonitoring) Example {
	monitor := parentMonitor.ForExternalService("Example")
	callbacks := Callbacks{
		OnStart: func(ctx context.Context, req *http.Request) {
			monitor.IncreaseCounter(ctx, monitoring.CounterRequest, utils.GetPath(req))
		},

		OnFinish: func(ctx context.Context, req *http.Request, startTime time.Time) {
			monitor.IncreaseCounter(ctx, monitoring.CounterOKResponse, utils.GetPath(req))
			monitor.UpdateMetrics(ctx, utils.GetPath(req), startTime)
		},

		OnError: func(ctx context.Context, req *http.Request, err error) {
			if _, ok := err.(*ServiceError); !ok {
				monitor.IncreaseCounter(ctx, monitoring.CounterName500, utils.GetPath(req))
			}
		},

		OnPanic: func(ctx context.Context, req *http.Request, r interface{}, trace []byte) {
			monitor.IncreaseCounter(ctx, monitoring.CounterName500, utils.GetPath(req))
			logger.Error(ctx, "panic calling service \"Example\": "+string(trace))
		},

		OnPrepareRequest: func(ctx context.Context, req *http.Request) {
			gotrace.SetHeaderRequestFromContext(ctx, req.Header)
		},
	}
	return Example{NewExampleGoRPC(client, balancer, callbacks)}
}
